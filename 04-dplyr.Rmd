---
title: Manipulating and Analyzing Data with dplyr
---

------------

# About plyr

Bracket subsetting is handy, but it can be cumbersome and difficult to read,
especially for complicated operations. Enter `dplyr`!

`dplyr` is a package for making data manipulation easier. (It does a lot more too, but this is what we'll focus on).

```{r, eval = FALSE}
install.packages("dplyr")
```
Again, you may be asked to choose a CRAN mirror; RStudio is a good choice.

Now unlike the `rmarkdown` package, we'll be using `dplyr` in the console. In order to do that, we need to _load_ the package into our environment so we can access functions from `dplyr`. We do this with the `library` command:

```{r, message = FALSE}
library("dplyr")
```

You only need to install a package once per computer, but you need to load it
every time you open a new R session and want to use that package.


## Subsetting Data

The first two `dplyr` commands we'll use help us to subset our data by rows and columns.

### `select`
The first command we'll use is `select`, which allows us to choose columns from our dataset. Let's use our `cats` dataset and select only the `coat` column; we did this previously with
```{r, eval=FALSE}
cats[, "coat"]
```

With dplyr, we don't need to enclose our column names in quotes
```{r, eval=FALSE}
select(cats, coat)
```

Notice how the output differs slightly; all the main `dplyr` verbs behave consistently in that their inputs and outputs are both `data.frame`s, rather than returning a simple vector as the bracket-indexing method did.

We can select more columns by giving `select` additional arguments, and our output `data.frame` will have columns according to the order of our arguments
```{r, eval=FALSE}
select(cats, coat, cat_id)
```

### `filter`
So where `select` allowed us to select _columns_, `filter` operated on _rows_. Say we want to see the all the cats with black coats; we saw earlier how to use that using bracket-indexing:
```{r, eval=FALSE}
cats[cats$coat == "black", ]
```

In dplyr, this looks like
```{r, eval=FALSE}
filter(cats, coat == "black")
```

Notice we don't have to use the `$` operator to tell `filter` where the `coat` column is; it's smart enough to assume we want the `coat` column from the `data.frame` we passed in.



<!-- ### Pipes -->

<!-- But what if you wanted to select and filter? There are three ways to do this: -->
<!-- use intermediate steps, nested functions, or pipes. With the intermediate steps, -->
<!-- you essentially create a temporary data frame and use that as input to the next -->
<!-- function. This can clutter up your workspace with lots of objects. You can also -->
<!-- nest functions (i.e. one function inside of another).  This is handy, but can be -->
<!-- difficult to read if too many functions are nested as the process from inside -->
<!-- out. The last option, pipes, are a fairly recent addition to R. Pipes let you -->
<!-- take the output of one function and send it directly to the next, which is -->
<!-- useful when you need to many things to the same data set.  Pipes in R look like -->
<!-- `%>%` and are made available via the `magrittr` package installed as -->
<!-- part of `dplyr`. -->

<!-- ```{r, purl = FALSE} -->
<!-- metadata %>% -->
<!--   filter(cit == "plus") %>% -->
<!--   select(sample, generation, clade) -->
<!-- ``` -->

<!-- In the above we use the pipe to send the `metadata` data set first through -->
<!-- `filter`, to keep rows where `cit` was equal to 'plus', and then through `select` to -->
<!-- keep the `sample` and `generation` and `clade` columns. When the data frame is being passed to the -->
<!-- `filter()` and `select()` functions through a pipe, we don't need to include it -->
<!-- as an argument to these functions anymore. -->

<!-- If we wanted to create a new object with this smaller version of the data we -->
<!-- could do so by assigning it a new name: -->

<!-- ```{r, purl = FALSE} -->
<!-- meta_citplus <- metadata %>% -->
<!--   filter(cit == "plus") %>% -->
<!--   select(sample, generation, clade) -->

<!-- meta_citplus -->
<!-- ``` -->

<!-- > ### Challenge {.challenge} -->
<!-- > -->
<!-- > Using pipes, subset the data to include rows where the clade is 'Cit+'. Retain columns -->
<!-- > `sample`, `cit`, and `genome_size.` -->

<!-- ### Mutate -->

<!-- Frequently you'll want to create new columns based on the values in existing -->
<!-- columns, for example to do unit conversions or find the ratio of values in two -->
<!-- columns. For this we'll use `mutate()`. -->

<!-- To create a new column of genome size in bp: -->

<!-- ```{r, purl = FALSE, eval=FALSE} -->
<!-- metadata %>% -->
<!--   mutate(genome_bp = genome_size *1e6) -->
<!-- ``` -->

<!-- If this runs off your screen and you just want to see the first few rows, you -->
<!-- can use a pipe to view the `head()` of the data (pipes work with non-dplyr -->
<!-- functions too, as long as the `dplyr` or `magrittr` packages are loaded). -->

<!-- ```{r, purl = FALSE, eval=FALSE} -->
<!-- metadata %>% -->
<!--   mutate(genome_bp = genome_size *1e6) %>% -->
<!--   head -->
<!-- ``` -->

<!-- The row has a NA value for clade, so if we wanted to remove those we could -->
<!-- insert a `filter()` in this chain: -->

<!-- ```{r, purl = FALSE, eval=FALSE} -->
<!-- metadata %>% -->
<!--   mutate(genome_bp = genome_size *1e6) %>% -->
<!--   filter(!is.na(clade)) %>% -->
<!--   head -->
<!-- ``` -->

<!-- `is.na()` is a function that determines whether something is or is not an `NA`. -->
<!-- The `!` symbol negates it, so we're asking for everything that is not an `NA`. -->

<!-- ### Split-apply-combine data analysis and the summarize() function -->

<!-- Many data analysis tasks can be approached using the "split-apply-combine" -->
<!-- paradigm: split the data into groups, apply some analysis to each group, and -->
<!-- then combine the results. `dplyr` makes this very easy through the use of the -->
<!-- `group_by()` function. `group_by()` splits the data into groups upon which some -->
<!-- operations can be run. For example, if we wanted to group by citrate-using mutant status and find the -->
<!-- number of rows of data for each status, we would do: -->

<!-- ```{r, purl = FALSE} -->
<!-- metadata %>% -->
<!--   group_by(cit) %>% -->
<!--   tally() -->
<!-- ``` -->

<!-- There are several different summary statistics that can be generated from our data. The R base package provides many built-in functions such as `mean`, `median`, `min`, `max`, and `range`.  By default, all **R functions operating on vectors that contains missing data will return NA**. It's a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. When dealing with simple statistics like the mean, the easiest way to ignore `NA` (the missing data) is to use `na.rm=TRUE` (`rm` stands for remove). -->

<!-- `group_by()` is often used together with `summarize()` which collapses each -->
<!-- group into a single-row summary of that group. `summarize()` can then be used to apply a function such as those that compute simple stats to give an overview for the group. So to view mean `genome_size` by mutant status: -->

<!-- ```{r, purl = FALSE} -->
<!-- metadata %>% -->
<!--   group_by(cit) %>% -->
<!--   summarize(mean_size = mean(genome_size, na.rm = TRUE)) -->
<!-- ``` -->

<!-- You can group by multiple columns too: -->

<!-- ```{r, purl = FALSE} -->
<!-- metadata %>% -->
<!--   group_by(cit, clade) %>% -->
<!--   summarize(mean_size = mean(genome_size, na.rm = TRUE)) -->

<!-- ``` -->

<!-- Looks like for one of these clones, the clade is missing. We could then discard those rows using `filter()`: -->

<!-- ```{r, purl = FALSE, eval=FALSE} -->
<!-- metadata %>% -->
<!--   group_by(cit, clade) %>% -->
<!--   summarize(mean_size = mean(genome_size, na.rm = TRUE)) %>% -->
<!--   filter(!is.na(clade)) -->
<!-- ``` -->

<!-- All of a sudden this isn't running of the screen anymore. That's because `dplyr` -->
<!-- has changed our `data.frame` to a `tbl_df`. This is a data structure that's very -->
<!-- similar to a data frame; for our purposes the only difference is that it won't -->
<!-- automatically show tons of data going off the screen. -->

<!-- You can also summarize multiple variables at the same time: -->

<!-- ```{r, purl = FALSE, eval=FALSE} -->
<!-- metadata %>% -->
<!--   group_by(cit, clade) %>% -->
<!--   summarize(mean_size = mean(genome_size, na.rm = TRUE), -->
<!--             min_generation = min(generation)) -->

<!-- ``` -->



<!-- [Handy dplyr cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) -->

<!-- *Much of this lesson was copied or adapted from Jeff Hollister's [materials](http://usepa.github.io/introR/2015/01/14/03-Clean/)* -->

